<!DOCTYPE html>
<html>
<style>
	:root {
		--var-color-file-drop: #9292ff
	}

	.v-row {
		display: flex;
		flex-direction: row;
	}

	.v-col {
		display: flex;
		flex-direction: column;
	}
</style>

<body>
	<v-crop-image></v-crop-image>
</body>

<script>
	class VEventEmitter {
		/**
		 * @type {Record<string, Array<{
		 * 		fn: ()=> {},
		 * 		scope: unknown,
		 * 		once: boolean,
		 * 		didCallOnce: boolean
		 * 	}>>
		 * }
		 * */
		#listeners = {};

		constructor() {
		}

		on(evName, fn, scope, { once } = {}) {
			if (!this.#listeners[evName]) this.#listeners[evName] = [];

			this.#listeners[evName].push({
				fn, scope, once
			});
		}

		off(evName, fn, scope) {
			if (!this.#listeners[evName]) return;

			const listenersArr = this.#listeners[evName];
			const len = listenersArr.length;
			for (let i = len - 1; i >= 0; i--) {
				const listener = listenersArr[i];
				if ((scope == listener.scope) || (fn == listener.fn)) {
					listenersArr.splice(i, 1);
				}
			}
		}

		async emit(evName, opts = {}, ...args) {
			const listenersArr = this.#listeners[evName] || [];
			for (const listener of listenersArr) {
				const didGetCalledOnce = listener.didCallOnce;
				if (listener.once) listener.didCallOnce = true;

				if (!listener.once || !didGetCalledOnce) {
					await Promise.resolve(listener.fn.apply(listener.scope, args));
				}
			}

			const len = listenersArr.length;
			for (let i = len - 1; i >= 0; i--) {
				if (listenersArr[i].once) listenersArr.splice(i, 1);
			}
		}
	}

	class VSimpleComponent extends HTMLElement {
		#mapOfDebounce = new Map();
		constructor() {
			super();

			this.evEmitter = new VEventEmitter();
			this.refs = new Proxy({}, {
				get: (_targ, prop) => {
					return this.querySelectorAll(`[ref=${prop}]`);
				}
			});
			const html = this.constructor.template.content.cloneNode(true);
			this.append(html);
		}

		/**
		 * @param {string} str
		 */
		static camelToHyphen(str) {
			return str
				.replace(str.charAt(0), str.charAt(0).toLowerCase())
				.replace(/[A-Z]/g, (substr) => {
					return `-${substr.replace(substr.charAt(0), substr.charAt(0).toLowerCase())}`;
				});
		}

		debounce(fn, ms = 300) {
			const oldTimeoutID = this.#mapOfDebounce.get(fn);
			clearTimeout(oldTimeoutID);

			const timeoutID = setTimeout(fn, ms);
			this.#mapOfDebounce.set(fn, timeoutID);
		}

		static define() {
			const tagName = this.camelToHyphen(this.name);
			if (customElements.get(tagName)) return;
			this.template = document.currentScript.previousElementSibling
			customElements.define(tagName, this);
		}

		connectedCallback() {
			this.evEmitter.emit('mounted');
		}

		disconnectedCallback() {
			this.evEmitter.emit('unmounted');
		}
	}
	
	window.VSimpleComponent = VSimpleComponent
</script>

<template>
	<div ref="refDragAndDropContainer" style="
				border: 2px dashed var(--var-color-file-drop);
				display: flex;
				flex-direction: row;
				justify-content: center;
			">
		<p style="color: var(--var-color-file-drop); font-weight: 900;">
			Drop Files Here
		</p>
	</div>
</template>
<script>
	class VDragAndDrop extends VSimpleComponent {
		constructor() {
			super();

			this._mounted = this._mounted.bind(this);
			this._unmounted = this._unmounted.bind(this);
			this._handleDragOver = this._handleDragOver.bind(this);
			this._handleDrop = this._handleDrop.bind(this);

			this.evEmitter.on('mounted', this._mounted);
			this.evEmitter.on('unmounted', this._unmounted);
		}

		_mounted() {
			const dndElem = this.refs.refDragAndDropContainer[0];
			dndElem.addEventListener("drop", this._handleDrop);
			dndElem.addEventListener("dragover", this._handleDragOver);
		}
		
		_handleDragOver(ev) {
			ev.stopPropagation();
			ev.preventDefault();
			ev.dataTransfer.dropEffect = "copy"
			const dndElem = this.refs.refDragAndDropContainer[0];
			dndElem.style.boxShadow = "0px 0px 4px black inset";
		}

		/**
		 * @param {Event} ev
		 */
		_handleDrop(ev) {
			ev.stopPropagation();
			ev.preventDefault();
			const dndElem = this.refs.refDragAndDropContainer[0];
			dndElem.style.boxShadow = "";

			const files = ev.dataTransfer.files.length
				? ev.dataTransfer.files
				: [...ev.dataTransfer.items]
					.filter((item) => item.kind === "file")
					.map((item) => item.getAsFile);
			
			this.evEmitter.emit('files', undefined, ev, files);
		}

		_unmounted() {
			const dndElem = this.refs.refDragAndDropContainer[0];
			dndElem.removeEventListener("drop", this._handleDrop);
			dndElem.removeEventListener("dragover", this._handleDragOver);
		}
	}

	VDragAndDrop.define();
</script>

<template>
	<v-drag-and-drop ref="refDragAndDrop"></v-drag-and-drop>
	<div class="v-col">
		<p>height: </p>
		<div class="v-row">
			<canvas ref="refHiddenCanvas" style="display: none;"></canvas>
			<canvas ref="refCanvas"></canvas>
			<p>width:</p>
		</div>
	</div>
</template>
<script>
	class VDropImage extends VSimpleComponent {
		constructor() {
			super();

			this._mounted = this._mounted.bind(this);
			this._unmounted = this._unmounted.bind(this);
			this._handleFiles = this._handleFiles.bind(this);

			this.evEmitter.on('mounted', this._mounted);
			this.evEmitter.on('unmounted', this._unmounted);
		}

		/**
		 * @param {Event}
		 * @param {File[]}
		 */
		_handleFiles(ev, files) {
			const canvas = this.refs.refCanvas[0],
			context = canvas.getContext('2d');
			const urlCreator = window.URL || window.webkitURL;
			const hiddenCanvas = this.refs.refHiddenCanvas[0];

			const base_image = new Image();
			base_image.onload = function() {
				hiddenCanvas.width = canvas.width = this.width;
				hiddenCanvas.height = canvas.height = this.height;
				context.drawImage(base_image, 0, 0, this.width, this.height);
				hiddenCanvas.getContext("2d").drawImage(base_image, 0, 0, this.width, this.height);
				urlCreator.revokeObjectURL(base_image.src);
			}
			base_image.src = urlCreator.createObjectURL(files[0]);
		}

		_mounted() {
			const dndElem = this.refs.refDragAndDrop[0];
			dndElem.evEmitter.on("files", this._handleFiles);
		}

		_unmounted() {
			const dndElem = this.refs.refDragAndDrop[0];
			dndElem.evEmitter.off("files", this._handleFiles);
		}
	}

	VDropImage.define();
</script>

<template>
	<div class="v-col" style="width: 50vw; align-items: center; justify-content: center;">
		<input ref="refPaddingTop" style="width: auto;" type="number" placeholder="top" value="0"/>
		<div class="v-row" style="align-items: center; justify-content: center;">
			<input ref="refPaddingLeft" style="width: 100%;" type="number" placeholder="left" value="0"/>
			<div>crop</div>
			<input ref="refPaddingRight" style="width: 100%;" type="number" placeholder="right" value="0"/>
		</div>
		<input ref="refPaddingBottom" style="width: auto;" type="number" placeholder="bottom" value="0"/>
	</div>
	<br/>
	<v-drop-image></v-drop-image>
</template>
<script>
	class VCropImage extends VSimpleComponent {
		constructor() {
			super();

			this._mounted = this._mounted.bind(this);
			this._unmounted = this._unmounted.bind(this);
			this._handleValueChange = this._handleValueChange.bind(this);
			this.debounce = this.debounce.bind(this);
			this.updateCanvas = this.updateCanvas.bind(this);

			this.evEmitter.on("mounted", this._mounted);
			this.evEmitter.on("unmounted", this._unmounted);
		}

		_mounted() {
			/** @type {HTMLInputElement} */
			const paddingTop = this.refs.refPaddingTop[0];
			paddingTop.addEventListener("change", this._handleValueChange);
			/** @type {HTMLInputElement} */
			const paddingLeft = this.refs.refPaddingLeft[0];
			paddingLeft.addEventListener("change", this._handleValueChange);
			/** @type {HTMLInputElement} */
			const paddingRight = this.refs.refPaddingRight[0];
			paddingRight.addEventListener("change", this._handleValueChange);
			/** @type {HTMLInputElement} */
			const paddingBottom = this.refs.refPaddingBottom[0];
			paddingBottom.addEventListener("change", this._handleValueChange);
		}

		_unmounted() {
			
		}

		_handleValueChange() {
			this.debounce(this.updateCanvas);
		}

		updateCanvas() {
			/** @type {HTMLInputElement} */
			const paddingTop = this.refs.refPaddingTop[0];
			/** @type {HTMLInputElement} */
			const paddingRight = this.refs.refPaddingRight[0];
			/** @type {HTMLInputElement} */
			const paddingBottom = this.refs.refPaddingBottom[0];
			/** @type {HTMLInputElement} */
			const paddingLeft = this.refs.refPaddingLeft[0];
			
			/** @type {HTMLCanvasElement} */
			const canvas = this.refs.refCanvas[0];
			const hiddenCanvas = this.refs.refHiddenCanvas[0];

			const newX = (Number(paddingLeft.value) || 0);
			const newY = (Number(paddingTop.value) || 0)
			const newWidth = canvas.width + (Number(paddingRight.value) || 0) - newX;
			const newHeight = canvas.height + (Number(paddingBottom.value) || 0) - newY;

			const oldContext = canvas.getContext("2d");
			oldContext.clearRect(0, 0, canvas.width, canvas.height);
			canvas.width = newWidth;
			canvas.height = newHeight;
			oldContext.drawImage(hiddenCanvas, Number(paddingLeft.value) || 0, Number(paddingTop.value) || 0, hiddenCanvas.width, hiddenCanvas.height);
		}
	}

	VCropImage.define();
</script>

</html>